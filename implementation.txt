####################
2021.09.29

Ontology:
- Classes: person, company
- Predicates: name(company union person -> string), worksFor(person -> company), isLeadBy (company -> person)

Database:
- t_person(pid, cid, pname, junk)
- t_company(cid, pid, cname, junk)

Suppose that we have the following mapping rules:
c(X):- T.A(X).
r(X,Y):- T.A1(X), T.A2(Y).

Naively
- person can be assigned to 8 table-attribute pairs.
- company can be assigned to 4 attributes in the other table.
- name can be assigned to 3 different attibutes for each class, giving 3 * 3 = 9 options
- worksFor can be assigned to any of the remaining 4 attributes (in either table)
- isLeadBy can be assigned to any of the remaining 3 attributes (in either table)

This is 8*4*9*4*3 = 3456 possible mappings.
We can eliminate many mappings based on type information.

If we have any supervision on person/company, we can quickly eliminate all but two candidate columns for each: persons live in the pid columns, companies live in the cid columns
If we have any supervision on worksFor/isLeadBy, we can quickly eliminate a lot of mappings purely based on what column pairs contain  the supervision pairs
If we have supervision with more then pairs, we can eliminate more mappings, again based on what constants individual columns hold.

Suppose that after all this elimination, some of the mappings are known:
person(X):- t_person.pid(X).
company(X):- t_company.cid(X).
name(X:person, Y):- t_person.pid(X), t_person.pname(Y).
name(X:company, Y):- t_company.cid(X), t_company.cname(Y).
worksFor(X, Y):- t_person.pid(X), t_person.cid(Y).

So we only need to figure out where isLeadBy reside. There are four candidates:
isLeadBy(X, Y):- t_person.pid(Y), t_person.cid(X).
isLeadBy(X, Y):- t_person.pid(Y), t_person.junk(X).
isLeadBy(X, Y):- t_company.cid(X), t_company.pid(Y). # correct one
isLeadBy(X, Y):- t_company.cid(X), t_company.junk(Y).

Our mapping rule is like the aboves, but the body contains auxiliary predicates:
isLeadBy(X, Y):- T.A1(X), T.A2(Y).
Matching the candidates with our mapping rule gives scores s1, s2, s3, s4.
We evaluate the database according to the four candidates and calculate an aggregate score for all of our supervision.
The best coverage is provided by candidate#3, so a gradient step would move towards T->t_company, A1->cid, A2->pid,
making s3 higher in the next round (and possibly but not necessarily making s1, s2, s4 smaller).

This is the learning algorithm we had in mind. However, as soon as candidate#3 performs best, we can just stop and say that this is going to be our mapping.
Why would we bother with learning?

####################
2021.09.29

Note about the formalism:
When I say below that
T.A1(Y) where T_A2=X
this is not a proper logical expression, but an sql query. It should be read as

T'(C_1, C_2, â€¦C_k), C_{I(A1)}=Y, C_{I(A2)}=X
where I is a mapping from column names in table T to their position in relation T'

*********************


problem_set: npd_user_tests
query: query1.qpair

*********************
name=Who are the licensees of production licence X and how big is their share?
orderNum=1

sql=SELECT DISTINCT a.prlName, a.cmpLongName, a.prlLicenseeInterest, a.prlLicenseeDateValidTo FROM licence_licensee_hst a WHERE a.prlLicenseeDateValidTo IN (SELECT MAX(b.prlLicenseeDateValidTo) FROM licence_licensee_hst b WHERE a.prlName = b.prlName GROUP BY b.prlName) ORDER BY a.prlName

sparql=prefix npdv: <http://sws.ifi.uio.no/vocab/npd-v2> \n\
SELECT DISTINCT ?licence ?licensee ?interest ?date WHERE { ?licenceURI a npdv:ProductionLicence ; npdv:name ?licence . [ ] a npdv:ProductionLicenceLicensee ; npdv:dateLicenseeValidFrom ?date ; npdv:licenseeInterest ?interest ; npdv:licenceLicensee [ npdv:name ?licensee ] ; npdv:licenseeForLicence ?licenceURI . { SELECT ?licenceURI (MAX(?d) AS ?date) WHERE { [ ] a npdv:ProductionLicenceLicensee ; npdv:dateLicenseeValidFrom ?d ; npdv:licenseeForLicence ?licenceURI . } GROUP BY ?licenceURI } } ORDER BY ?licence DESC(?interest)

entityIdCols=
entityIdVars=
*********************

mapping rules:

npdv:ProductionLicence(X):-
  source conditions: license_licensee_hst.prlnpdidlicence(X)

npdv:ProductionLicenceLicensee(X):-
  source conditions: license_licensee_hst.cmpnpdidcompany(X)

npdv:name(X, Y):-
  target conditions: rdf:type(X, npdv:ProductionLicence)
  source conditions: license_licensee_hst.prlName(Y) where license_licensee_hst.prlnpdidlicence = X

npdv:dateLicenseeValidFrom(X,Y):-
  target conditions: rdf:type(X, npdv:ProductionLicenceLicensee)
  source conditions: license_licensee_hst.prlLicenseeDateValidTo(Y) where license_licensee_hst.cmpnpdidcompany = X
  # note there is probably a bug in the provided sql as it uses DateValidTo instead of DateValidFrom

npdv:licenseeInterest(X, Y):-
  target conditions: rdf:type(X, npdv:ProductionLicenceLicensee)
  source_conditions: license_licensee_hst.prlLicenseeInterest(Y) where license_licensee_hst.cmpnpdidcompany = X

npdv:licenceLicensee(X,Y):-
  target conditions: rdf:type(X, npdv:ProductionLicenceLicensee)
  source conditions: license_licensee_hst.cmpLongName(Y) where license_licensee_hst.cmpnpdidcompany = X
  # note this is an approximation. Y is in fact an entity (company) whose :name property is license_licensee_hst.cmpLongName


####################

Use the RODI benchmark

Supervision:
SQL query tells us what we want to obtain when we run the sparql query

x rdf:type C:
  Q.id gives you all x

  Q1.id gives you all x, but other relations are in Q2
  Q1 natural join Q2

x y z:
  x and z should have corresponding rdf:type edges and they come from
  the id column of the corresponding tables
  call them table(x) and table(z)

  if y is a functional property, then it should correspond to a column col
  in table(x), i.e., (x,z) pairs are
  (table(x).id, table(x).col)

  if y is an inverse functional property, then it should correspond to a column col
  in table(z), i.e., (x,z) pairs are
  (table(z).col, table(z).id)

  if y is not a functional property, then look for a table
  corresponding to y and identify the column corresponding to z

  if y is not a functional property, then look for a table
  corresponding to z and identify the inverse column corresponding to
  x


  create an fixed embedding vector for each sql table
  create a trainable embedding vector for each owl:Class
  these have to be matched during training

  create a fixed embedding vector for each column name in each sql
  table
  create a trainable embedding vector for each
  owl:FunctionalProperty
  these have to be matched
  TODO: assume that the same column name is not used in different
  tables to mean different things

  same as above for owl:InverseFunctionalProperty


  for each functional property
  create a fixed embedding vector for each column of each table

  for each functional property, create an embedding vector

  create a trainable embedding vector  for


Bind each class C_i to a table T_i
Bind each functional property to
     - column in class table of subject T_s.p
Bind each inverse functional property to
     - column in class table of object T_o.p
Bind each plain property to a table T_prop_i

SELECT count(*)
FROM T_i, T_prop_j
WHERE T_i.id = T_prop_j.xxx


generate problems automatically (sparql, sql, triples, selects)
try brute force mapping search

automatically compare sql and transformed sql results


One query from npd
atomic-ZValueTo.qpair
sparql=SELECT ?x ?y { ?x <http://sws.ifi.uio.no/vocab/npd-v2#ZValueTo> ?y }

Solution is the union of two tables (tables and subject columns are specified in comments in the ontology)

Object is harder as it is split in multiple columns

'http://sws.ifi.uio.no/data/npd-v2/licence/' + TABLE1.prlNpdidLicence +
'/area/' + TABLE1.prlArea_id +
'/history/', TABLE1.prlAreaPolyDateValidFrom +
'/', TABLE1.prlAreaPolyDateValidTo

union

'http://sws.ifi.uio.no/data/npd-v2/licence/' + TABLE1.prlNpdidLicence +
'/block/' + TABLE1.blcName +
'/polyno/' + TABLE1.prlAreaPolyPolyNo +
'/history/' + TABLE1.prlAreaPolyDateValidFrom +
'/' + TABLE1.prlAreaPolyDateValidTo


C(x):- 
